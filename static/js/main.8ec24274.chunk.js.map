{"version":3,"sources":["shaders/fragmentShader.js","shaders/vertexShader.js","shaders/ChromaticAbberationShader.js","components/ThreeCanvas.jsx","App.js","index.js"],"names":["fragmentShader","vertexShader","ChromaticAbberationShader","defines","BAND_MODE","CHROMA_SAMPLES","uniforms","tDiffuse","value","baseIor","bandOffset","jitterIntensity","jitterOffset","ThreeJS_Scene","options","this","time","container","domEl","scene","THREE","fog","width","offsetWidth","height","offsetHeight","mouse","cameraDistance","camera","position","z","fov","Math","atan","PI","raycaster","renderer","antialias","setPixelRatio","min","window","devicePixelRatio","appendChild","domElement","controls","OrbitControls","composerPass","addObjects","resize","render","mouseMovement","composer","EffectComposer","setSize","renderPass","RenderPass","addPass","filmPass","FilmPass","unrealBloomPass","UnrealBloomPass","distortPass","ShaderPass","material","needsUpdate","addEventListener","event","x","pageX","y","pageY","u_mouse","bind","u_resolution","aspect","updateProjectionMatrix","geometry","u_time","side","mesh","add","cancelAnimationFrame","raf","removeEventListener","rotation","requestAnimationFrame","ThreeCanvas","containerRef","useRef","useEffect","THREE_INSTANCE","current","destroy","ref","className","App","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8ec24274.chunk.js","sourcesContent":["export const fragmentShader = `\n  // Fragement Shader setzt die Farbe für jeden Pixel\n\n  varying float vDistort;\n  varying vec2 vUv;\n  varying float vMousePos;\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n  // uniform vec2 u_hover; \n  float PI = 3.14159265359;\n\n  vec3 cosPalette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n      return a + b * cos(6.28318 * (c * t + d));\n  } \n    \n  float quarticInOut(float t) {\n    return t < 0.5\n      ? +8.0 * pow(t, 4.0)\n      : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n  }\n\n  float map(float value, float min1, float max1, float min2, float max2) {\n    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n  }\n\n  void main()\t{\n    float intensity = 6.0;\n    float distort = vDistort * intensity;\n\n    vec2 position = gl_FragCoord.xy / u_resolution.xy;\n\n    vec3 brightness = vec3(0.7, 0.7, 0.7);\n    vec3 contrast = vec3(0.5);\n    vec3 oscilation = vec3(0.008);\n    vec3 phase = vec3(0.2);\n    float mouse = map(vMousePos * 5.0, -3.0, 1.0, 0.0, 1.0 );\n\n    float randGlow = (sin(2. * PI + u_time / 1.8) + 10.0) * 0.02;\n\n    float glow = quarticInOut(clamp(mouse, 0.1, 0.2) + randGlow);\n\n    vec3 color = cosPalette(distort, brightness, contrast, oscilation, phase) * glow;\n\n    gl_FragColor = vec4(color, 1.0);\n  }\n`","export const vertexShader = `\n  // Vertex Shader verändert die Position jedes Vertex (die Punkte im Mesh)\n  varying vec2 vUv;\n  varying float vMousePos;\n  varying float vDistort;\n  uniform float u_time;\n  uniform vec2 u_mouse;\n\n  // uniform vec2 u_hover; \n\n  // GLSL textureless classic 3D noise \"cnoise\",\n  // with an RSL-style periodic variant \"pnoise\".\n  // Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n  // Version: 2011-10-11\n  //\n  // Many thanks to Ian McEwan of Ashima Arts for the\n  // ideas for permutation and gradient selection.\n  //\n  // Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n  // Distributed under the MIT license. See LICENSE file.\n  // https://github.com/ashima/webgl-noise\n  //\n\n  vec3 mod289(vec3 x)\n  {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n\n  vec4 mod289(vec4 x)\n  {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n\n  vec4 permute(vec4 x)\n  {\n    return mod289(((x*34.0)+1.0)*x);\n  }\n\n  vec4 taylorInvSqrt(vec4 r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n\n  vec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n  }\n\n  // Classic Perlin noise, periodic variant\n  float pnoise(vec3 P, vec3 rep)\n  {\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n  }\n\n  mat3 rotation3dY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat3(\n      c, 0.0, -s,\n      0.0, 1.0, 0.0,\n      s, 0.0, c\n    );\n  }\n\n  vec3 rotateY(vec3 v, float angle) {\n    return rotation3dY(angle) * v;\n  }  \n\n  void main() {\n    vUv = uv;\n\n    float mousePos = 1.0 - ( 2.0 * max(abs(u_mouse.x), abs(u_mouse.y)) );\n    vMousePos = mousePos;\n\n    float scale = clamp(1.0 - abs(abs(u_mouse.x) + abs(u_mouse.y)), 1.0, 1.05);\n\n\n    float speed = 0.01;\n    float mouseMorph = u_mouse.x / 15.;\n\n    float t = u_time * speed;\n    float frequency = 2.9;\n    float amplitude = 2.;\n    float noiseDensity = 7.2;\n    float noiseStrength = 8.;\n    float noiseScale = 1.0;\n    vec3 repetitions = vec3(2.0);\n  \n    float distortion = pnoise((normal * noiseScale + t) * noiseDensity, repetitions) * noiseStrength;\n    vDistort = distortion;\n\n    vec3 pos = position + (normal * distortion);\n    float angle = sin(uv.y * frequency + t) * amplitude;\n    pos = rotateY(pos, angle);    \n\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos * (scale + mousePos * 0.02), 1.);\n  }\n`\n","export const ChromaticAbberationShader = {\n\n\tdefines: {\n\n\t\t// 0: NONE, 1: RGB, 2: RYGCBV\n\t\tBAND_MODE: 2,\n\n\t\tCHROMA_SAMPLES: 1,\n\n\t},\n\n\tuniforms: {\n\n\t\ttDiffuse: { value: null },\n\t\tbaseIor: { value: 0.075 },\n\t\tbandOffset: { value: 0.003 },\n\t\tjitterIntensity: { value: 1.0 },\n\t\tjitterOffset: { value: 0.0 },\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 viewDir;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tviewDir = normalize( ( modelViewMatrix * vec4( position, 1.0 ) ).xyz );\n\t\t}\n\t`,\n\n\tfragmentShader: /* glsl */`\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 viewDir;\n\t\tuniform float baseIor;\n\t\tuniform float bandOffset;\n\t\tuniform float jitterIntensity;\n\t\tuniform float jitterOffset;\n\t\tuniform sampler2D tDiffuse;\n\t\t#include <common>\n\t\tvoid main() {\n\t\t\tvec3 normal = vec3( ( 2.0 * vUv - vec2( 1.0 ) ), 1.0 );\n\t\t\tnormal.z = 1.0;\n\t\t\tnormal = normalize( normal );\n\t\t\tvec3 color;\n\t\t\t// if NO BANDS\n\t\t\t#if BAND_MODE == 0\n\t\t\tvec3 refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor );\n\t\t\tcolor = texture2D( tDiffuse, vUv + refracted.xy ).rgb;\n\t\t\t// if RGB or RYGCBV BANDS\n\t\t\t#else\n\t\t\tfloat index, randValue, offsetValue;\n\t\t\tfloat r, g, b, r_ior, g_ior, b_ior;\n\t\t\tvec3 r_refracted, g_refracted, b_refracted;\n\t\t\tvec4 r_sample, g_sample, b_sample;\n\t\t\t#if BAND_MODE == 2\n\t\t\tfloat y, c, v, y_ior, c_ior, v_ior;\n\t\t\tvec3 y_refracted, c_refracted, v_refracted;\n\t\t\tvec4 y_sample, c_sample, v_sample;\n\t\t\t#endif\n\t\t\tfor ( int i = 0; i < CHROMA_SAMPLES; i ++ ) {\n\t\t\t\tindex = float( i );\n\t\t\t\trandValue = rand( sin( index + 1. ) * gl_FragCoord.xy + vec2( jitterOffset, - jitterOffset ) ) - 0.5;\n\t\t\t\toffsetValue = index / float( CHROMA_SAMPLES ) + randValue * jitterIntensity;\n\t\t\t\t#if BAND_MODE == 1\n\t\t\t\trandValue *= 2.0;\n\t\t\t\t#endif\n\t\t\t\t// Paper describing functions for creating yellow, cyan, and violet bands and reforming\n\t\t\t\t// them into RGB:\n\t\t\t\t// https://web.archive.org/web/20061108181225/http://home.iitk.ac.in/~shankars/reports/dispersionraytrace.pdf\n\t\t\t\tr_ior = 1.0 + bandOffset * ( 0.0 + offsetValue );\n\t\t\t\tg_ior = 1.0 + bandOffset * ( 2.0 + offsetValue );\n\t\t\t\tb_ior = 1.0 + bandOffset * ( 4.0 + offsetValue );\n\t\t\t\tr_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / r_ior );\n\t\t\t\tg_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / g_ior );\n\t\t\t\tb_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / b_ior );\n\t\t\t\tr_sample = texture2D( tDiffuse, vUv + r_refracted.xy );\n\t\t\t\tg_sample = texture2D( tDiffuse, vUv + g_refracted.xy );\n\t\t\t\tb_sample = texture2D( tDiffuse, vUv + b_refracted.xy );\n\t\t\t\t#if BAND_MODE == 2\n\t\t\t\ty_ior = 1.0 + bandOffset * ( 1.0 + offsetValue );\n\t\t\t\tc_ior = 1.0 + bandOffset * ( 3.0 + offsetValue );\n\t\t\t\tv_ior = 1.0 + bandOffset * ( 5.0 + offsetValue );\n\t\t\t\ty_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / y_ior );\n\t\t\t\tc_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / c_ior );\n\t\t\t\tv_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / v_ior );\n\t\t\t\ty_sample = texture2D( tDiffuse, vUv + y_refracted.xy );\n\t\t\t\tc_sample = texture2D( tDiffuse, vUv + c_refracted.xy );\n\t\t\t\tv_sample = texture2D( tDiffuse, vUv + v_refracted.xy );\n\t\t\t\tr = r_sample.r / 2.0;\n\t\t\t\ty = ( 2.0 * y_sample.r + 2.0 * y_sample.g - y_sample.b ) / 6.0;\n\t\t\t\tg = g_sample.g / 2.0;\n\t\t\t\tc = ( 2.0 * c_sample.g + 2.0 * c_sample.b - c_sample.r ) / 6.0;\n\t\t\t\tb = b_sample.b / 2.0;\n\t\t\t\tv = ( 2.0 * v_sample.b + 2.0 * v_sample.r - v_sample.g ) / 6.0;\n\t\t\t\tcolor.r += r + ( 2.0 * v + 2.0 * y - c ) / 3.0;\n\t\t\t\tcolor.g += g + ( 2.0 * y + 2.0 * c - v ) / 3.0;\n\t\t\t\tcolor.b += b + ( 2.0 * c + 2.0 * v - y ) / 3.0;\n\t\t\t\t#else\n\t\t\t\tcolor.r += r_sample.r;\n\t\t\t\tcolor.g += g_sample.g;\n\t\t\t\tcolor.b += b_sample.b;\n\t\t\t\t#endif\n\t\t\t}\n\t\t\tcolor /= float( CHROMA_SAMPLES );\n\t\t\t#endif\n\t\t\tgl_FragColor = vec4( color, 1.0 );\n\t\t}\n\t`,\n\n};","import { useEffect, useRef } from 'react'\n\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { fragmentShader } from '../shaders/fragmentShader.js' \nimport { vertexShader } from '../shaders/vertexShader.js'\n\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';\nimport { FilmPass } from 'three/examples/jsm/postprocessing/FilmPass.js';\nimport { ChromaticAbberationShader } from '../shaders/ChromaticAbberationShader.js';\n\nclass ThreeJS_Scene {\n    constructor(options){\n        this.time = 0; \n        this.container = options.domEl;\n        this.scene = new THREE.Scene();\n        this.scene.fog = new THREE.FogExp2( 0x000000, 0.001 );\n\n        this.width = this.container.offsetWidth;\n        this.height = this.container.offsetHeight;\n\n        this.mouse = new THREE.Vector2();\n\n        this.cameraDistance = 600;\n        this.camera = new THREE.PerspectiveCamera( 70, this.width/this.height, 100, 2000 );\n        this.camera.position.z = this.cameraDistance;\n\n        // Set Camera FOV (Damit Objekte die korrekte Größe haben => 100px on Screen = 100px in THREE)\n        this.camera.fov = 2*Math.atan( (this.height/2) / this.cameraDistance ) * (180/Math.PI);\n\n        this.raycaster = new THREE.Raycaster();\n\n        this.renderer = new THREE.WebGLRenderer( { \n            antialias: true,\n            // alpha: true\n        } );\n\n        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\n        // this.renderer.getContext().getExtension('OES_standard_derivatives');\n        \n        this.container.appendChild( this.renderer.domElement );\n\n        this.controls = new OrbitControls( this.camera, this.renderer.domElement );\n\n        this.composerPass();\n        this.addObjects();\n        this.resize();\n        this.render();\n\n        this.mouseMovement();\n        \n    }\n\n\n    composerPass(){\n        this.composer = new EffectComposer(this.renderer);\n        this.composer.setSize(this.width, this.height);\n        this.composer.setPixelRatio( window.devicePixelRatio );\n        this.renderPass = new RenderPass(this.scene, this.camera);\n        this.composer.addPass(this.renderPass);\n\n        this.filmPass = new FilmPass(1, 0, 0, 0);\n        this.composer.addPass( this.filmPass );\n\n        this.unrealBloomPass = new UnrealBloomPass( this.width / this.height, 1.0, 1.5, 0);\n        this.composer.addPass( this.unrealBloomPass );\n\n        this.distortPass = new ShaderPass( ChromaticAbberationShader );\n        this.distortPass.material.defines.CHROMA_SAMPLES = 2;\n        this.distortPass.material.defines.BAND_MODE = 0;\n        this.distortPass.material.needsUpdate = true;\n        this.composer.addPass( this.distortPass );\n\n    }\n\n\n    mouseMovement(){\n        window.addEventListener( 'mousemove', (event) => {\n            this.mouse.x = ( event.pageX / this.width ) * 2 - 1;\n            this.mouse.y = - ( event.pageY / this.height ) * 2 + 1;\n\n            this.uniforms.u_mouse.value = this.mouse;\n\n        }, false );\n    }\n\n    setupResize(){\n        window.addEventListener('resize',this.resize.bind(this));\n    }\n\n    resize(){\n        this.width = this.container.offsetWidth;\n        this.height = this.container.offsetHeight;\n        this.uniforms.u_resolution.value.x = this.width;\n        this.uniforms.u_resolution.value.y = this.height;\n\n        this.renderer.setSize( this.width, this.height );\n        this.camera.aspect = this.width / this.height;\n        this.camera.updateProjectionMatrix();\n    }\n\n    addObjects(){\n        this.geometry = new THREE.IcosahedronBufferGeometry( 200, 100 )\n        this.material = new THREE.MeshNormalMaterial();\n\n        this.uniforms = {\n            u_time: { value:0 },\n            u_resolution: { value: new THREE.Vector2(this.width, this.height) },\n            u_mouse: { value: new THREE.Vector2(0,0) }\n        }\n\n        this.material = new THREE.ShaderMaterial({\n            uniforms: this.uniforms,\n            side: THREE.DoubleSide,\n            fragmentShader: fragmentShader,\n            vertexShader: vertexShader\n        })\n\n        this.mesh = new THREE.Mesh( this.geometry, this.material );\n        this.scene.add( this.mesh );\n    }\n\n    destroy(){ \n      window.cancelAnimationFrame(this.raf)\n      window.removeEventListener('resize', this.resize)\n\n    }\n\n    render(){\n        this.time+=0.05;      \n        \n        this.mesh.rotation.y = this.time / 40;\n        this.mesh.rotation.z = this.time / 65;\n\n        this.material.uniforms.u_time.value = this.time;\n\n        this.distortPass.material.uniforms.baseIor.value = 0.9;\n        this.distortPass.material.uniforms.bandOffset.value = 0.003;\n        this.distortPass.material.uniforms.jitterOffset.value += 0.1;\n        this.distortPass.material.uniforms.jitterIntensity.value = 0.2;\n\n        this.composer.render();\n        \n        this.raf = window.requestAnimationFrame(this.render.bind(this));\n    }\n}\n\n\nfunction ThreeCanvas() {\n  // Container ref\n  const containerRef = useRef();\n\n  useEffect(()=> {\n    let THREE_INSTANCE = new ThreeJS_Scene({\n      domEl: containerRef.current,\n      vertexShader,\n      fragmentShader\n    })\n\n    return () => {\n      THREE_INSTANCE.destroy()\n      THREE_INSTANCE = null;\n    }\n  }, [])\n\n  return (\n    <div ref={containerRef} className=\"h-screen w-screen\"></div>\n  )\n}\n\nexport default ThreeCanvas\n","import ThreeCanvas from \"./components/ThreeCanvas\"\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <ThreeCanvas/>\n    </div> \n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './css/index.css'; \nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}